---
layout: post
title: "[SPRING] - 스프링 프레임워크 입문"
date: 2019-09-06 12:10:28 -0900
categories: web
---
# SpringFramwork

### Inversion of Control

- **IoC**

  - 의존성을 외부에서 주입하는 것을 뜻한다.

  ```java
  //일반적인 컨트롤러
  //일반적인 의존성에 대한 제어권
  class OwnerController {
    private OwnerRepository repo = 
      new OwnerRepository();
  }
  ```

  ```java
  //Inversion of Controller
  //의존성을 외부에서 주입한다.
  class OwnerController {
    private OwnerRepository repo;
    
    public OwnerController(OwnerRepository repo) {
      this.repo = repo;
    }
  }
  ```

- **IoC  Container**

  - Bean을 생성하고 엮어주며 제공해준다.

- **Bean**

  - Spring IoC Container가 관리하는 객체

  - <u>등록하는 방법</u>

    1. Component Scanning
       - @Component (@Repository, @Service, @Controller 내부에 존재)가 붙으면 Bean으로 등록된다.
       - @Bean을 정의할 때 @Configuration이 있는 클래스 안에 정의해야 등록된다. (메소드 명이 빈의 이름이 된다.)
    2. 직접 XML, Java 설정 파일에 등록

  - <u>사용하는 방법</u>

    - @Autowired OR @Inject

    - ApplicationContext에서 getBean()으로 직접 꺼내기

      ```java
      //Bean 등록
      @Bean
      public String testBean() {
        return "bean";
      }
      
      //Bean 사용
      @Autowired
      String testBean;
      
      @Autowired
      ApplicationContext applicationContext;
      
      public void test() {
        //ApplicationContext를 이용하지 않고 Bean 사용하기
        testBean;
        
      	//ApplicationContext를 이용한 Bean 사용하기
      applicationContext.getBean("testBean");
      }
      ```

      

- **Dependency Injection(의존성 주입)**

  - 필요한 의존성을 받아오기 위해 @Autowired / @Inject를 어디에 붙일까?
    - 생성자, 필드, Setter
    - 기본적으로 생성자에 붙이고, 의존성이 한 개만 있다면 위 어노테이션을 붙이는 것을 추천한다.
    - @Autowired를 붙이기 위해 Setter를 만드는 것은 의존성을 바꿀 수 있는 위험한 코딩이 될 수 있다. 의존성에 대한 Setter가 존재하면 Setter에 붙이고, 아니면 필드에 붙인다.
  - [@Resource / @Autowired / @Inject의 차이점](https://itjava.tistory.com/54)

### Aspect Oriented Programming

- AOP

  - 흩어진 코드를 한 곳으로 모우는 코딩 기법

- AOP 적용 예제

  ```java
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface LogExecutionTime {
  }
  
  @Component
  @Aspect
  public class LogAspect {
    Logger logger = LoggerFactory.getLogger(LogAspect.class);
    
    @Around("@annotation(LogExecutionTime)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
      StopWatch stopWatch = new StopWatch();
      stopWatch.start();
      
      Object proceed = joinPoint.proceed();
      
      stopWatch.stop();
      logger.info(stopWatch.prettyPrint());
      
      return proceed;
    }
  }
  ```

- [@Around, @Before, @After....  AOP 실행 흐름에 끼어들기(1)](https://offbyone.tistory.com/34)

- [@Around, @Before, @After..... AOP 실행 흐름에 끼어들기(2)](https://jeong-pro.tistory.com/171)

### Portable Service Abstraction

- PSA (잘 만든 인터페이스)
- Spring Transaction
  - PlatformTransactionManager
    - JpaTrasactionalManager
    - DatasourceTransactionalManager
    - HibernateTransactionalManager
    - 구현체는 다양하다.
- Cache
  - CacheManager
    - JCacheManager
    - ConcurrentMapCacheManager
    - EhCacheCacheManager
  - @EnableCaching  : 캐시 관련된 기능이 활성화 된다.
- Spring Web MVC
  - Servletd이나 Reactive를 바꾸어도 추상화가 잘 되어 있기 때문에 대부분의 코드가 변경되지 않는다.