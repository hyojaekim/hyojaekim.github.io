---
layout: post
title: "REST API"
date: 2019-12-01 14:50:28 -0900
description: 이응준님의 그런 REST API로 괜찮은가 발표 영상을 참고하여 REST API에 대해 정리하였습니다.
categories: etc
---

REST API는 개발을 하다보면 한번쯤 접하게 되는 용어이다. REST API에 대해 대충은 알고 있지만, 어떻게 설명해야 할지 몰라서 정리해봐야겠다고 생각했다. REST API에 대한 자료를 찾다가 DEVIEW에서 이응준님의 '그런 REST API로 괜찮은가' 영상을 봤다. REST API가 등장하게 된 이유부터, 어떤 에피소드가 있었는지 흥미롭게 설명을 잘하셔서 재밌게 봤다. 이번 글은 영상을 참고하여 REST API에 대해 정리하려고 한다.

<blockquote>REST</blockquote>

개발자라면 REST라는 단어를 한번은 접하게 된다.

***"그 부분은 REST스럽지 않은 것 같아요"***

***"그건 REST API가 아니야"***

REST는 자주 접하면서도 REST에 대해 설명하라고 했을때 의미가 뚜렷하지 않은 느낌이 있다. 그럼 REST 정의를 한번 알아보자.

**[REST - REpresentational State Transfer](https://ko.wikipedia.org/wiki/REST)**

위키를 참고해도 여전히 모르겠다. REST가 어떻게 등장하게 되었는지 알아보자.

<blockquote>REST의 등장</blockquote>

### WEB (1991)

***"어떻게 인터넷에서 정보를 공유할 것인가?"***

팀 버너스리는 정보들을 하이퍼텍스트로 연결하고, HTML로 표현하고, URI로 식별하며, 전송 방법은 HTTP를 사용하기로 한다.

### HTTP/1.0 (1994-1996)

HTTP 프로토콜을 여러명에서 설계하게 되었는데 그 중에 **로이 필딩이라는 사람은 아래와 같은 고민을 했다.**

***"이미 웹은 급속도로 발전하고 있는데 어떻게 하면 기존의 웹에 영향을 주지 않고, 진보시킬까?"***

### HTTP Object Model
위 해결책으로 **HTTP Object Model**이라는 것을 만들었다. HTTP Object Model은 또 뭘까?

### REST(2000)

**4년 후(1998)에 로이 필딩은 HTTP Object Model을 Microsoft Research에서 REST라는 이름**으로 발표하고, **2년 후에 박사 논문으로 다시 발표를 하게 된다.**
2000년에 나온 박사 논문이 **오늘날의 알고 있는 REST를 정의하는 논문이다.**

### API

인터넷 상에 API라는 것을 만들기 시작했는데 1998년도에 Microsoft에서 XML-RPC라는 것을 만들었는데 SOAP라는 이름으로 바뀐다.

2000년도에 Salesforce에서 API를 공개했다. 하지만 복잡해서 인기가 없었다. 4년 뒤(2004) flickr에서 여러가지 형태로 SOAP랑 비슷한 형태, REST 이름을 따온 단순한 형태로 API 공개했다.

***"SOAP는 복잡하고, 규칙이 많고, 어려운데 REST는 단순하고, 규칙이 적고, 쉬워요"***

사람들은 이러한 느낌을 받게 된다. **결국 SOAP API는 인기가 추락하고, REST API는 인기가 급상승 하게 되어서 REST가 승리하게 된다.**

### 로이 필딩의 REST API
2008년에 CMIS가 REST 바인딩을 지원했는데 **로이 필딩은 CMIS에 REST가 없다고 얘기한다.**

2016년에 **Microsoft에서 REST API 가이드라인을 만들게 된다.**

* URI는 https://{serviceRoot}/{collection}/{id} 형식이어야한다.
* GET, PUT, DELETE, POST, HEAD, PATCH, OPTIONS를 지원해야한다.
* API 버저닝은 Major.minor로 하고 URI에 버전 정보를 포함시킨다
* 등등..

로이 필딩은 이것도 REST API가 아니고 HTTP API라고 얘기한다. 또, REST API는 hypertext-driven이어야 하고, 최고의 버저닝 전략은 버저닝을 안하는 것이라고 발표한다. **그럼 REST API, REST를 따져보자.**

<blockquote>REST API, REST</blockquote>

**REST API는 REST 아키텍쳐 스타일을 따르는 API이다.** REST는 뭘까?

**REST는 분산 하이퍼미디어 시스템(ex 웹)을 위한 아키텍쳐 스타일이다.** 아키텍쳐 스타일은 뭘까?

**아키텍쳐 스타일은 제약조건의 집합을 의미한다.**

### REST를 구성하는 스타일
* client-server
* stateless
* cache
* **uniform interface**
* layered system
* code-on-demand (optional)

대체로 **HTTP만 잘 따라도 client-server, stateless, cache, layered system을 지킬 수 있다.**

**code-ondemand는 서버에서 코드를 클라이언트로 보내서 실행할 수 있어야한다는 것을 말한다. (javascript)**

이 중에 **uniform interface는 잘 만족시키지 못하고 있는데 uniform interface에 대해 알아보자.**

<blockquote>Uniform interface의 제약조건</blockquote>

1. 리소스가 URI로 식별되면 된다.
2. 리소스를 만들거나, 업데이트하거나, 삭제하거나 HTTP 메세지에 포함해서 전송해야한다.
3. **self-descriptive message**
4. **hypermedia as the engine of application state (HATEOAS)**

1번, 2번은 잘 만족하고 있지만 **3번, 4번은 자칭 REST API라고 알려진 모든 것들은 이 두가지를 만족하지 못하고 있다.** 3번, 4번에 대해 한번 알아보자.

### 메시지는 스스로를 설명해야한다. (Self-descriptive message)

**메시지만 봤을 때 한눈에 해석이 가능해야 하는데 오늘날에는 이부분을 잘 지키지 못하고 있다.**

```
GET / HTTP/1.1
```

해당 요청은 단순히 루트로 이동하는 GET 요청이다. 그런데 메시지만 봤을 때 한눈에 해석이 가능한가? 이미 알고 있는 사람은 가능하겠지만, 이러한 요청을 처음 접하는 사람은 무엇을 요청하는지 이해하기 힘들다. 따라서 Self-descriptive 하지 못하다.

```
GET / HTTP/1.1
Host: www.test.com
```

기존의 요청에 목적지를 추가하면 해당 도메인으로 이동하는 것을 알 수 있기 때문에 Self-descriptive하다.

```
HTTP/1.1 200 OK

[{ "id": "test", "path": "a/b/c" }]
```

위 응답을 보면 클라이언트가 어떤 문법으로 작성되었는지 모르기 때문에 Self-descriptive하지 못하다.

```
HTTP/1.1 200 OK
Content-Type: application/json

[{ "id": "test", "path": "a/b/c" }]
```
위 응답도 사실 Self-descriptive하지 못하다. 왜냐하면 어떻게 파싱해야 하는지 명시하지 않았다.

```
HTTP/1.1 200 OK
Content-Type: application/json-patch+json

[{ "id": "test", "path": "a/b/c" }]
```
위와 같이 명시해줘야 해당 명세를 찾아가서 해석 하고, 올바르게 의미를 이해할 수 있다. 그런데 명세에 json문서를 파싱하는 방법은 있지만, 'id'가 무엇을 의미하고, 'path'가 무엇을 의미하는지 알 방법은 없다.

오늘날 미디어 타입을 보면 보통 json이라고만 되어있고, 위와 같이 명시해주는 경우가 많이 없기 때문에 Self-descriptive를 잘 지키지 못하고 있다.

### 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야한다. (HATEOAS)

HTML은 a링크를 통해서 다음 상태로 전이가 가능하고, JSON으로 표현해도 Link라는 헤더가 다른 리소스를 가리킬 수 있기 때문에 HATEOAS를 만족한다.

<blockquote>왜 Uniform interface가 필요한가</blockquote>

### 독립적 진화

***"HTTP를 고치면 웹이 깨질것 같은데 어떻게 이 문제를 해결할까?"***

로이 필딩이 고민했던 부분이자 **REST가 목적하는 바가 독립적인 진화를 달성하기 위해서이다.**

서버와 클라이언트가 각각 독립적으로 진화하면 **서버에서 변경이 생겨도 클라이언트는 업데이트할 필요가 없다.** 이게 바로 REST를 만들게 된 계기이다.

### REST가 지켜지고 있는가?

* 웹 페이지 변경시 웹 브라우저를 업데이트할 필요는 없다.
* 웹 브라우저 업데이트 시 웹 페이지를 변경할 필요도 없다.
* HTTP 명세가 변경되어도 웹은 잘 동작한다.
* HTML 명세가 변경되어도 웹은 잘 동작한다.

물론 페이지가 깨질 수 있지만, 동작은 한다. 그런데 모바일 앱에서는 업데이트 할 때마다 제대로 동작하지 않는 경우를 볼 수 있다. 웹은 이런 경우가 잘 없는데 앱은 REST로 통신하고 있지 않다고 생각한다.

<blockquote>웹은 어떻게 독립적 진화가 가능할까?</blockquote>

**HTML5 초안에서 권고안 나오는데 6년, HTTP/1.1 명세 개정판 작업하는데 7년**

많은 시간이 걸렸지만 기능은 하나도 추가되지 않았다. 문서만 다듬기만 하는데 7년이 걸렸는데 그 이유는 **하위호안성을 깨트리지 않기 위함이다.** 이 노력이 있기 때문에 웹은 독립적으로 진화가 가능하다.

### 상호운용성(interoperability)에 대한 집착

웹은 상호운영성에 대한 집착을 많이 했기 때문에 독립적으로 진화할 수 있었다. 얼마나 집착했는지 몇가지 에피소드를 보자.

1. **Referer은 오타**

HTTP 헤더 중에 Referer은 Referrer의 오타지만 고치는 순간 웹이 깨지기 때문에 고치지 않았다. HTTP/1.1 개정판에서도 HTTP/2.0에서도 고쳐지지 않을 것이다.

2. **charset은 잘못 지은 이름**

charset은 인코딩이라고 지어야 하는데 인코딩에 대한 개념이 없어서 character set이랑 같은 줄 알고 지은 이름이다.

3. **HTTP 상태 코드 416 포기 (I'm a teapot)**

HTTP 상태 코드가 추가되면서 416을 추가하려고 하는데 서버 구현체들이 다른 프로토콜의 416 상태 코드를 이미 구현했었다.

처음에 HTTP 의장이 프로젝트마다 돌아다니면서 416 제거하라고 했는데 비난을 받고 포기하여, 416번을 영구 결번하고 415에서 417로 넘어갔다.

이렇게까지 하는 이유가 이미 구현체가 세상에 존재하기 때문에 잘못 만들어진 구현체들과의 상호운용성을 지켜줘야 하기 때문에 포기했다.

4. **HTTP/0.9 지원 (크롬, 파이어폭스)**

크롬에서 0.9를 빼봤는데 몇몇 프록시에서 동작하지 않아서 아직도 HTTP/0.9를 지원한다.

<blockquote>자칭 REST API</blockquote>

REST API는 REST 아키텍쳐 스타일을 따라야한다. 스스로 REST API라고 하는 API들의 대부분이 따르지 않는다.

### 제약조건을 다 지켜야 하는가?

***"REST API는 하이퍼텍스트를 포함한 Self-descriptive한 메시지의 uniform interface를 통해 리소스에 접근하는 API다"***

로이 필딩은 위와 같이 지켜야한다고 말한다.

***"SOAP는 복잡하고, 규칙이 많고, 어려운데 REST는 단순하고, 규칙이 적고, 쉬워요"***

**초반에는 사람들이 위와 같이 느꼈는데 오늘날에는 REST도 어렵다고 느낀다.**

### 꼭 REST API이어야 하나?

***"시스템 전체를 통제할 수 있다고 생각하거나 진화에 관심이 없다면, REST에 대해 따지느라 시간을 낭비하지 마라."***

로이 필딩은 이렇게 얘기한다. **시스템 전체를 통제한다는건 뭘까?**

**시스템 전체를 통제할 수 있다는건 마음대로 만들 수 있는 상황을 의미한다.**
또, **진화에 관심없다는건 업데이트에 대한 문제가 크게 상관다고 느끼는 것이다.**

그럼 이제 어떻게 할까?

1. REST API를 구현하고 REST API라고 부른다
2. REST API 구현을 포기하고 HTTP API라고 부른다.
3. **REST API가 아니지만 REST API라고 부른다. (현재 상태)**

모든 제약조건을 따르기에는 비용이고, 시간이다. 그래서 대부분의 REST API라고 불리는 것이 3번을 의미하는게 아닐까?

### Self-descriptive와 HATEOAS가 독립적 진화에 어떻게 도움이 되는가?

* Self-descriptive 하면 메시지만 있어도 해석이 가능하기 때문에 **확장 가능한 커뮤니케이션을 가능하게 한다.**

* HATEOAS 애플리케이션 상태 전이의 late binding
어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 다음 전이될 상태가 결정된다. **즉, 서버가 링크를 바꾼다고 해도 클라이언트 동작은 문제가 없다. 서버가 링크는 동적으로 변경될 수 있다. 따라서 독립적인 진화가 가능하다.**

<blockquote>REST API로 고쳐보자</blockquote>

### Self-descriptive

**방법 1 - Media Type**

1. 미디어 타입을 정의한다.
2. id가 뭐고 title이 뭔지 의미를 정의한다.
3. 모든 미디어 타입을 등록되어 있는 IANA에 미디어 타입을 등록한다.

**매번 미디어 타입을 정의해야하므로 번거롭다.**

**방법 2 - Profile**

1. id가 뭐고 title이 뭔지 의미를 정의한 명세를 작성한다.
2. Link 헤더에 profile relation으로 해당 명세를 링크한다.
3. 메시지를 보는 사람은 명세를 찾아갈 수 있어, 문서의 의미를 온전히 해석할 수 있다.

**클라이언트가 Link 헤더와 profile을 이해해야하며, Content negotiation을 할 수 없다.**

### HATEOAS

**방법1**
* 데이터에 다양한 방법으로 하이퍼링크를 표현한다. 링크를 표현하는 방법을 직접 정의해야 하는 단점이 있다.
* JSON으로 하이퍼링크를 표현하는 방법을 이용한다.

**방법2**
* Link, Location 등의 헤더로 링크를 표현한다.

**하이퍼링크는 반드시 URI여야 하는건 아니고, 하이퍼링크를 표현하기만 하면 괜찮다. 미디어 타입 등록은 필수이지 않다. 의도한 저자가 이해할 수만 있으면 상관없다.**

<blockquote>요약</blockquote>

* 오늘날 대부분의 "REST API"는 사실 REST를 따르지 않고 있다.
* REST의 제약조건 중 특히 **Self-descriptive & HATEOAS를 잘 만족하지 못한다.**
* REST는 **긴 시간에 걸쳐 진화하는 웹 애플리케이션을 위한 것이다.**
* REST를 따를 것인지는 API를 설계하는 이들이 **스스로 판단하여 결정한다.**
* **REST를 따르겠다면, Self-descriptive와 HATEOAS를 만족시켜야 한다.**
  * Self-descriptive는 Media Type을 커스텀하거나 Profile link relation 등으로 만족시킬 수 있다.
  * HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.
* **REST를 따르지 않겠다면, REST를 만족하지 않는 REST API를 뭐라고 부를지 결정해야 한다.**
  * HTTP API나, 로이 필딩이 싫어하지만 이대로 REST API라고 부를 것인지
