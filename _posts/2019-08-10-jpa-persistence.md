---
layout: post
title: "[JPA] - 영속성 관리"
date: 2019-08-10 13:45:28 -0900
categories: web
---

### **영속성 컨텍스트 ( Persistence Context )**

논리적인 개념에 가깝고, **엔티티를 영구 저장하는 환경**을 뜻한다.

엔티티를 저장하거나, 조회하면 **엔티티 매니저**는 **영속성 컨텍스트**에 엔티티를 **보관**하고 **관리**한다.

```java
em.persist(member);
```

위 코드는 ~~단순히 회원 엔티티를 저장한다기 보다,~~ ***엔티티 매니저를 사용해 회원 엔티티를 영속성 컨텍스트에 저장한다.***

### 엔티티 생명주기

* **비영속(new)**
	* 영속성 컨텍스트와 전혀 관계가 없는 상태

	![new](/assets/image/persistence/new.png)
	```java
	Member  member = new  Member();
	member.setId("abc");
	member.setUsername("홍길동");
	```

* **영속(managed)**
	* 영속성 컨텍스트에 의해 괸리 되는 상태

	![managed](/assets/image/persistence/managed.png)
	```java
	em.persist(member);
	em.find();
	```

* **준영속(detached)**
	* 영속성 컨텍스트가 관리하던 엔티티가 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
	```java
	/* 준영속 상태로 만드는 방법 3가지 */

	/* 1.특정 엔티티만 준영속 상태로 전환 */
	em.detach(member);

	/* 2. 영속성 컨텍스트를 완전히 초기화 */
	em.clear();

	/* 3. 영속성 컨텍스트를 종료 */
	em.close();
	```
	
* **삭제(removed)**
	*  엔티티를 영속성 컨텍스트와 DB에서 삭제한다.

	```java
	em.remove(member);
	```

### **영속성 컨텍스트 특징**
* 영속성 컨텍스트 내부에 캐시를 가지고 있다. (**1차 캐시**)
* 영속 상태 엔티티는 모두 이곳에 저장되며, 내부에 **@Id로 매핑한 식별자로 엔티티 인스턴스를 찾을 수 있는 Map이 존재**한다.

	```java
	/* 1차 캐시에 있는 엔티티 조회하기 */
	Member member = new Member();
	member.setId("one");

	/* 1차 캐시에 저장 */
	em.persist(member);

	/* 1차 캐시에서 조회 */
	Member findMember = em.find(Member.class, "one");
	```
* 엔티티 조회 시, 1차 캐시에 엔티티가 없는 경우
	1. 엔티티 매니저는 DB를 조회한다.
	2. 엔티티를 생성한다.
	3. 1차 캐시에 저장한다.
	4. 영속 상태의 엔티티를 반환한다.

* 엔티티 등록
	* 엔티티 매니저는 트랙잭션 커밋 직전까지, 내부 쿼리 저장소에 쿼리를 모아둔다.

	* **트랜잭션을 커밋**할 때, **내부 쿼리 저장소에 모아둔 쿼리**를 DB에 보낸다. (**쓰기 지연**)

* 엔티티 수정
	* **변경 감지**(dirty checking)로 인해 엔티티 변경사항을 DB에 자동으로 반영한다.
		* 영속 상태의 엔티티에만 적용된다.
		* 플러시(flush) 시점에 최초 상태를 저장해둔 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾아 수정 쿼리를 생성한다.
	
	` 수정할 때, 변경된 부분에 대해서 쿼리를 생성하는게 아니라, JPA에서는 기본적으로 모든 필드를 업데이트 한다.
	DynamicUpdate 어노테이션을 사용하면 수정된 데이터만 사용해 동적으로 쿼리를 생성할 수 있다.`
	* 모든 필드 업데이트 시 장점
		* **수정 쿼리가 항상 같다.**
		* 애플리케이션 로딩 시점에 **수정 쿼리를 미리 생성**하여, **재사용** 가능하다.

### 플러시(flush) 
영속성 컨텍스트의 변경 내용을 DB에 동기화 한다.
* **직접 호출** : em.flush() 메소드를 직접 호출하여, 영속성 컨텍스트르를 강제로 플러시한다.

* **트랜잭션 커밋 시 플러시 자동 호출** : **트랜잭션만 커밋하면 반영되지 않는다.** 따라서 커밋 플러시를 해야하기 때문에 **JPA**에서는 이런 문제를 방지하기 위해 **자동으로 호출**한다.

* **JPQL 쿼리 실행시 플러시 자동 호출** 